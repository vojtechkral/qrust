// Do not edit this file, it is auto-generated!

// Generated by qrust-gen
// Generator: GQSharedData
// Template:  qshareddata_rs.mako
// Timestamp: 2016-07-29T10:06:49Z

use std::mem;
use libc::*;


mod glue {
	use libc::*;

	extern {
		pub fn _qrust_qdir_c_1() -> *mut c_void;
		pub fn _qrust_qdir_m_filePath(this: *mut c_void, fileName: *mut c_void) -> *mut c_void;
		pub fn _qrust_qdir_m_isRelative(this: *mut c_void) -> c_int;
		pub fn _qrust_qdir_m_canonicalPath(this: *mut c_void) -> *mut c_void;
		pub fn _qrust_qdir_m_mkpath(this: *mut c_void, dirPath: *mut c_void) -> c_int;
		pub fn _qrust_qdir_m_setPath(this: *mut c_void, path: *mut c_void) -> ();
		pub fn _qrust_qdir_m_makeAbsolute(this: *mut c_void) -> c_int;
		pub fn _qrust_qdir_m_dirName(this: *mut c_void) -> *mut c_void;
		pub fn _qrust_qdir_m_remove(this: *mut c_void, fileName: *mut c_void) -> c_int;
		pub fn _qrust_qdir_m_refresh(this: *mut c_void) -> ();
		pub fn _qrust_qdir_m_mkdir(this: *mut c_void, dirName: *mut c_void) -> c_int;
		pub fn _qrust_qdir_m_rmpath(this: *mut c_void, dirPath: *mut c_void) -> c_int;
		pub fn _qrust_qdir_m_absolutePath(this: *mut c_void) -> *mut c_void;
		pub fn _qrust_qdir_m_absoluteFilePath(this: *mut c_void, fileName: *mut c_void) -> *mut c_void;
		pub fn _qrust_qdir_m_exists0(this: *mut c_void) -> c_int;
		pub fn _qrust_qdir_m_exists1(this: *mut c_void, name: *mut c_void) -> c_int;
		pub fn _qrust_qdir_m_cdUp(this: *mut c_void) -> c_int;
		pub fn _qrust_qdir_m_cd(this: *mut c_void, dirName: *mut c_void) -> c_int;
		pub fn _qrust_qdir_m_relativeFilePath(this: *mut c_void, fileName: *mut c_void) -> *mut c_void;
		pub fn _qrust_qdir_m_removeRecursively(this: *mut c_void) -> c_int;
		pub fn _qrust_qdir_m_rename(this: *mut c_void, oldName: *mut c_void, newName: *mut c_void) -> c_int;
		pub fn _qrust_qdir_m_rmdir(this: *mut c_void, dirName: *mut c_void) -> c_int;
		pub fn _qrust_qdir_m_path(this: *mut c_void) -> *mut c_void;
		pub fn _qrust_qdir_m_isReadable(this: *mut c_void) -> c_int;
		pub fn _qrust_qdir_m_isRoot(this: *mut c_void) -> c_int;
		pub fn _qrust_qdir_m_isAbsolute(this: *mut c_void) -> c_int;
		
	}
}

/// Access to directory structures and their contents
pub struct QDir(pub *mut c_void);

impl QDir
{
	pub fn new() -> QDir {
		QDir(unsafe { glue::_qrust_qdir_c_1() })
	}

	#[allow(non_snake_case)]
	pub fn filePath(&self, fileName: &QString) -> QString {
		return QString(unsafe { glue::_qrust_qdir_m_filePath(self.0, fileName.0) });
	}
	#[allow(non_snake_case)]
	pub fn isRelative(&self) -> bool {
		return unsafe { glue::_qrust_qdir_m_isRelative(self.0) } != 0;
	}
	#[allow(non_snake_case)]
	pub fn canonicalPath(&self) -> QString {
		return QString(unsafe { glue::_qrust_qdir_m_canonicalPath(self.0) });
	}
	#[allow(non_snake_case)]
	pub fn mkpath(&self, dirPath: &QString) -> bool {
		return unsafe { glue::_qrust_qdir_m_mkpath(self.0, dirPath.0) } != 0;
	}
	#[allow(non_snake_case)]
	pub fn setPath(&self, path: &QString) -> () {
		return unsafe { glue::_qrust_qdir_m_setPath(self.0, path.0) };
	}
	#[allow(non_snake_case)]
	pub fn makeAbsolute(&self) -> bool {
		return unsafe { glue::_qrust_qdir_m_makeAbsolute(self.0) } != 0;
	}
	#[allow(non_snake_case)]
	pub fn dirName(&self) -> QString {
		return QString(unsafe { glue::_qrust_qdir_m_dirName(self.0) });
	}
	#[allow(non_snake_case)]
	pub fn remove(&self, fileName: &QString) -> bool {
		return unsafe { glue::_qrust_qdir_m_remove(self.0, fileName.0) } != 0;
	}
	#[allow(non_snake_case)]
	pub fn refresh(&self) -> () {
		return unsafe { glue::_qrust_qdir_m_refresh(self.0) };
	}
	#[allow(non_snake_case)]
	pub fn mkdir(&self, dirName: &QString) -> bool {
		return unsafe { glue::_qrust_qdir_m_mkdir(self.0, dirName.0) } != 0;
	}
	#[allow(non_snake_case)]
	pub fn rmpath(&self, dirPath: &QString) -> bool {
		return unsafe { glue::_qrust_qdir_m_rmpath(self.0, dirPath.0) } != 0;
	}
	#[allow(non_snake_case)]
	pub fn absolutePath(&self) -> QString {
		return QString(unsafe { glue::_qrust_qdir_m_absolutePath(self.0) });
	}
	#[allow(non_snake_case)]
	pub fn absoluteFilePath(&self, fileName: &QString) -> QString {
		return QString(unsafe { glue::_qrust_qdir_m_absoluteFilePath(self.0, fileName.0) });
	}
	#[allow(non_snake_case)]
	pub fn exists0(&self) -> bool {
		return unsafe { glue::_qrust_qdir_m_exists0(self.0) } != 0;
	}
	#[allow(non_snake_case)]
	pub fn exists1(&self, name: &QString) -> bool {
		return unsafe { glue::_qrust_qdir_m_exists1(self.0, name.0) } != 0;
	}
	#[allow(non_snake_case)]
	pub fn cdUp(&self) -> bool {
		return unsafe { glue::_qrust_qdir_m_cdUp(self.0) } != 0;
	}
	#[allow(non_snake_case)]
	pub fn cd(&self, dirName: &QString) -> bool {
		return unsafe { glue::_qrust_qdir_m_cd(self.0, dirName.0) } != 0;
	}
	#[allow(non_snake_case)]
	pub fn relativeFilePath(&self, fileName: &QString) -> QString {
		return QString(unsafe { glue::_qrust_qdir_m_relativeFilePath(self.0, fileName.0) });
	}
	#[allow(non_snake_case)]
	pub fn removeRecursively(&self) -> bool {
		return unsafe { glue::_qrust_qdir_m_removeRecursively(self.0) } != 0;
	}
	#[allow(non_snake_case)]
	pub fn rename(&self, oldName: &QString, newName: &QString) -> bool {
		return unsafe { glue::_qrust_qdir_m_rename(self.0, oldName.0, newName.0) } != 0;
	}
	#[allow(non_snake_case)]
	pub fn rmdir(&self, dirName: &QString) -> bool {
		return unsafe { glue::_qrust_qdir_m_rmdir(self.0, dirName.0) } != 0;
	}
	#[allow(non_snake_case)]
	pub fn path(&self) -> QString {
		return QString(unsafe { glue::_qrust_qdir_m_path(self.0) });
	}
	#[allow(non_snake_case)]
	pub fn isReadable(&self) -> bool {
		return unsafe { glue::_qrust_qdir_m_isReadable(self.0) } != 0;
	}
	#[allow(non_snake_case)]
	pub fn isRoot(&self) -> bool {
		return unsafe { glue::_qrust_qdir_m_isRoot(self.0) } != 0;
	}
	#[allow(non_snake_case)]
	pub fn isAbsolute(&self) -> bool {
		return unsafe { glue::_qrust_qdir_m_isAbsolute(self.0) } != 0;
	}

	/// **Unsupported**
	#[allow(non_snake_case)]
	pub fn nameFilters(&self) -> ! {
		unimplemented!();
	}
	/// **Unsupported**
	#[allow(non_snake_case)]
	pub fn count(&self) -> ! {
		unimplemented!();
	}
	/// **Unsupported**
	#[allow(non_snake_case)]
	pub fn entryInfoList0(&self) -> ! {
		unimplemented!();
	}
	/// **Unsupported**
	#[allow(non_snake_case)]
	pub fn entryInfoList1(&self) -> ! {
		unimplemented!();
	}
	/// **Unsupported**
	#[allow(non_snake_case)]
	pub fn filter(&self) -> ! {
		unimplemented!();
	}
	/// **Unsupported**
	#[allow(non_snake_case)]
	pub fn setNameFilters(&self) -> ! {
		unimplemented!();
	}
	/// **Unsupported**
	#[allow(non_snake_case)]
	pub fn swap(&self) -> ! {
		unimplemented!();
	}
	/// **Unsupported**
	#[allow(non_snake_case)]
	pub fn entryList0(&self) -> ! {
		unimplemented!();
	}
	/// **Unsupported**
	#[allow(non_snake_case)]
	pub fn entryList1(&self) -> ! {
		unimplemented!();
	}
	/// **Unsupported**
	#[allow(non_snake_case)]
	pub fn setSorting(&self) -> ! {
		unimplemented!();
	}
	/// **Unsupported**
	#[allow(non_snake_case)]
	pub fn sorting(&self) -> ! {
		unimplemented!();
	}
	/// **Unsupported**
	#[allow(non_snake_case)]
	pub fn setFilter(&self) -> ! {
		unimplemented!();
	}
}

// TODO: Drop


