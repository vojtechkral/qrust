// Do not edit this file, it is auto-generated!

// Generated by qrust-gen
// Generator: GQObject
// Template:  qobject_rs.mako
// Timestamp: 2016-08-07T09:35:27Z

use std::mem;
use std::ptr::null_mut;
use libc::*;

use ::{TraitObject, FatPtr, QPtr, AsQPtr, Connection, Slot, IntoSlot};


// GLUE DECLS

mod glue {
	use libc::*;
	use ::TraitObject;

	extern {

		pub fn _qrust_qtimer_c_1() -> *mut c_void;

		pub fn _qrust_qtimer_m_isActive(this: *mut c_void) -> c_int;
		pub fn _qrust_qtimer_m_isSingleShot(this: *mut c_void) -> c_int;
		pub fn _qrust_qtimer_m_start0(this: *mut c_void) -> ();
		pub fn _qrust_qtimer_m_start1(this: *mut c_void, msec: c_int) -> ();
		pub fn _qrust_qtimer_m_timerId(this: *mut c_void) -> c_int;
		pub fn _qrust_qtimer_m_stop(this: *mut c_void) -> ();
		pub fn _qrust_qtimer_m_setSingleShot(this: *mut c_void, singleShot: c_int) -> ();
		pub fn _qrust_qtimer_m_interval(this: *mut c_void) -> c_int;
		pub fn _qrust_qtimer_m_setInterval(this: *mut c_void, msec: c_int) -> ();
		pub fn _qrust_qtimer_m_remainingTime(this: *mut c_void) -> c_int;
		pub fn _qrust_qtimer_C_timeout(obj: *mut c_void, callback: TraitObject, closure: c_int) -> *mut c_void;
		
	}
}

// NATIVE SLOTS
// TODO

pub mod slot
{
	#[allow(non_snake_case)]
	pub mod QTimer
	{
		use ::{AsQPtr, TraitObject, Slot};

		mod glue {
			use libc::*;

			extern {
				pub static mut _qrust_qtimer_S_close: *mut c_void;
			}
		}

		pub fn close(qobj: &::QTimer) -> Slot
		{
			Slot::Native(TraitObject
			{
				data: qobj.qptr(),
				vtable: unsafe { glue::_qrust_qtimer_S_close },
			})
		}
	}
}


// CLASS

/// Repetitive and single-shot timers
pub struct QTimer(QPtr);

impl QTimer
{

  pub fn new() -> QTimer {
		QTimer(unsafe { glue::_qrust_qtimer_c_1() })
	}


	// MEMBERS

	#[allow(non_snake_case)]
	pub fn isActive(&self) -> bool {
		return unsafe { glue::_qrust_qtimer_m_isActive(self.0) } != 0;
	}

	#[allow(non_snake_case)]
	pub fn isSingleShot(&self) -> bool {
		return unsafe { glue::_qrust_qtimer_m_isSingleShot(self.0) } != 0;
	}

	#[allow(non_snake_case)]
	pub fn start0(&self) -> () {
		return unsafe { glue::_qrust_qtimer_m_start0(self.0) };
	}

	#[allow(non_snake_case)]
	pub fn start1(&self, msec: i32) -> () {
		return unsafe { glue::_qrust_qtimer_m_start1(self.0, msec as c_int) };
	}

	#[allow(non_snake_case)]
	pub fn timerId(&self) -> i32 {
		return unsafe { glue::_qrust_qtimer_m_timerId(self.0) } as i32;
	}

	#[allow(non_snake_case)]
	pub fn stop(&self) -> () {
		return unsafe { glue::_qrust_qtimer_m_stop(self.0) };
	}

	#[allow(non_snake_case)]
	pub fn setSingleShot(&self, singleShot: bool) -> () {
		return unsafe { glue::_qrust_qtimer_m_setSingleShot(self.0, singleShot as c_int) };
	}

	#[allow(non_snake_case)]
	pub fn interval(&self) -> i32 {
		return unsafe { glue::_qrust_qtimer_m_interval(self.0) } as i32;
	}

	#[allow(non_snake_case)]
	pub fn setInterval(&self, msec: i32) -> () {
		return unsafe { glue::_qrust_qtimer_m_setInterval(self.0, msec as c_int) };
	}

	#[allow(non_snake_case)]
	pub fn remainingTime(&self) -> i32 {
		return unsafe { glue::_qrust_qtimer_m_remainingTime(self.0) } as i32;
	}


	// UNSUPPORTEDS

	/// **Unimplemented:** `QTimer::setTimerType(atype)`
	#[allow(non_snake_case)]
	pub fn setTimerType(&self) -> ! {
		unimplemented!();
	}

	/// **Unimplemented:** `QTimer::timerType()`
	#[allow(non_snake_case)]
	pub fn timerType(&self) -> ! {
		unimplemented!();
	}


	// SIGNALS

	#[allow(non_snake_case)]
	pub fn timeout<T>(&self, slot: T) -> Connection
		where T: IntoSlot<()>
	{
		let slot = slot.into_slot();
		slot.connect(|to, closure| -> *mut c_void
		{
			unsafe { glue::_qrust_qtimer_C_timeout(self.0, to, closure as c_int) }
		})
	}

}

impl AsQPtr for QTimer {
	fn qptr(&self) -> QPtr { self.0 }
	fn set_qptr(&mut self, qptr: QPtr) { self.0 = qptr; }
}


// SIGNAL CLOSURE TRAMPOLINES

#[no_mangle]
#[doc(hidden)]
#[allow(non_snake_case)]
pub extern fn _qrust_qtimer_T_timeout(callback: TraitObject) {
	let cb: Box<Fn() + 'static> = unsafe { Box::from_raw(mem::transmute(callback)) };
	cb();
	mem::forget(cb);
}



// SIGNAL CLOSURE DROPS

#[no_mangle]
#[doc(hidden)]
#[allow(non_snake_case)]
pub extern fn _qrust_qtimer_D_timeout(callback: TraitObject) {
	let _cb: Box<Fn() + 'static> = unsafe { Box::from_raw(mem::transmute(callback)) };
}




