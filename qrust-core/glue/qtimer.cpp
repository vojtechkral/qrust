// Do not edit this file, it is auto-generated!

// Generated by qrust-gen
// Generator: GQObject
// Template:  qobject_cpp.mako
// Timestamp: 2016-08-07T09:35:27Z

#include <iostream>
#include <QtCore/QTimer>
#include "common.h"

// FIXME: TMP
using std::cout;
using std::endl;


// MEMBER TRAMPOLINES


extern "C" void* _qrust_qtimer_c_1() {
	return new QTimer();
}


extern "C" int _qrust_qtimer_m_isActive(void* self) {
	return static_cast<QTimer*>(self)->isActive();
}
extern "C" int _qrust_qtimer_m_isSingleShot(void* self) {
	return static_cast<QTimer*>(self)->isSingleShot();
}
extern "C" void _qrust_qtimer_m_start0(void* self) {
	return static_cast<QTimer*>(self)->start();
}
extern "C" void _qrust_qtimer_m_start1(void* self, int msec) {
	return static_cast<QTimer*>(self)->start(msec);
}
extern "C" int _qrust_qtimer_m_timerId(void* self) {
	return static_cast<QTimer*>(self)->timerId();
}
extern "C" void _qrust_qtimer_m_stop(void* self) {
	return static_cast<QTimer*>(self)->stop();
}
extern "C" void _qrust_qtimer_m_setSingleShot(void* self, int singleShot) {
	return static_cast<QTimer*>(self)->setSingleShot(singleShot);
}
extern "C" int _qrust_qtimer_m_interval(void* self) {
	return static_cast<QTimer*>(self)->interval();
}
extern "C" void _qrust_qtimer_m_setInterval(void* self, int msec) {
	return static_cast<QTimer*>(self)->setInterval(msec);
}
extern "C" int _qrust_qtimer_m_remainingTime(void* self) {
	return static_cast<QTimer*>(self)->remainingTime();
}


// SLOTS:

const char* _qrust_qtimer_S_close = SLOT(close());


// SIGNALS:

extern "C" void _qrust_qtimer_T_timeout(TraitObject);
extern "C" void _qrust_qtimer_D_timeout(TraitObject);

class QTimer_timeout: public Signal
{
public:
	QTimer_timeout(TraitObject callback) :Signal(callback) {}
	virtual ~QTimer_timeout() { _qrust_qtimer_D_timeout(callback); }
public slots:
	void trampoline()
	{
		cout << "QTimer_timeout::trampoline" << endl;
		_qrust_qtimer_T_timeout(callback);
	}
};

extern "C" void* _qrust_qtimer_C_timeout(void* obj, TraitObject data, int closure)
{
	return Connection::connect<QTimer, QTimer_timeout>(
		obj, data, closure,
		&QTimer::timeout, SIGNAL(timeout()));
}



